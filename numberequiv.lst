     1                                  ;   Executable name         : uppercaser2
     2                                  ;   Version                 : 1.0
     3                                  ;   Created date            : 28 Dec 2018
     4                                  ;   Last update             : 28 Dec 2018
     5                                  ;   Author                  : Brian Hart
     6                                  ;   Description             : A simple program in assembly for Linux, using NASM,
     7                                  ;                             demonstrating simple text file I/O (through redirection) for reading an
     8                                  ;                             input file to a buffer in blocks, forcing lowercase characters to 
     9                                  ;                             uppercase, and writing the modified buffer to an output file.
    10                                  ;
    11                                  ;   Run it this way:
    12                                  ;       uppercaser2 > (output file) < (input file)
    13                                  ;
    14                                  ;   Build using these commands:
    15                                  ;       nasm -f elf64 -g -F stabs uppercaser2.asm
    16                                  ;       ld -o uppercaser2 uppercaser2.o
    17                                  ;
    18                                  SECTION     .bss                    ; Section contaning uninitialized data
    19                                  
    20                                        BUFFLEN equ 1024              ; Length of buffer
    21 00000000 <res 00000400>                Buff:   resb BUFFLEN          ; Text buffer itself
    22                                        
    23                                  SECTION     .data                   ; Section containing initialized data
    24                                  
    25                                  SECTION     .text                   ; Section containing code
    26                                  
    27                                  global      _start
    28                                  
    29                                  _start:
    30 00000000 90                              nop                         ; This no-op keeps gdb happy...
    31                                          
    32                                  ; Read a buffer-full of text from STDIN...
    33                                  Read:
    34 00000001 B803000000                      mov eax, 3                  ; Specify sys_read call
    35 00000006 BB00000000                      mov ebx, 0                  ; Specify File Descriptor 0: Standard Input
    36 0000000B B9[00000000]                    mov ecx, Buff               ; Pass offset of the buffer to read to
    37 00000010 BA00040000                      mov edx, BUFFLEN            ; Pass number of bytes to read at one pass
    38 00000015 CD80                            int 80h                     ; Call sys_read to fill the buffer
    39 00000017 89C6                            mov esi, eax                ; Copy sys_read return value for safekeeping
    40 00000019 83F800                          cmp eax, 0                  ; If eax=0, sys_read reached EOF on stdin
    41 0000001C 7438                            je Done                     ; Jump If Equal (to 0, from compare)
    42                                          
    43                                  ; Set up the registers for the process buffer step:
    44 0000001E 89F1                            mov ecx, esi                ; Place the number of bytes read into ECX
    45 00000020 BD[00000000]                    mov ebp, Buff               ; Place the address of the buffer into EBP
    46 00000025 FFCD                            dec ebp                     ; Adjust count to offset
    47                                          
    48                                  ; Go through the buffer and convert lowercase to uppercase characters:
    49                                  Scan:
    50 00000027 67807C0D0061                    cmp byte [ebp+ecx], 61h     ; Test input char against lowercase 'a'
    51 0000002D 720E                            jb Next                     ; If below 'a' in ASCII chart, not lowercase
    52 0000002F 67807C0D007A                    cmp byte [ebp+ecx], 7Ah     ; Test input char against lowercase 'z'
    53 00000035 7706                            ja Next                     ; If above 'z' in ASCII chart, not lowercase
    54                                                                      ; At this point, we have a lowercase char
    55 00000037 67806C0D0020                    sub byte [ebp+ecx], 20h     ; Subtract 20h to give uppercase...
    56                                  Next:
    57 0000003D FFC9                            dec ecx                     ; Decrement counter
    58 0000003F 75E6                            jnz Scan                    ; If characters remain, loop back
    59                                          
    60                                  ; Write the buffer full of processed text to STDOUT:
    61                                  Write:    
    62 00000041 B804000000                      mov eax, 4                  ; Specify sys_write call
    63 00000046 BB01000000                      mov ebx, 1                  ; Specify File Descriptor 1: Standard Input
    64 0000004B B9[00000000]                    mov ecx, Buff               ; Pass offset of the buffer
    65 00000050 89F2                            mov edx, esi                ; Pass the # of bytes of data in the buffer
    66 00000052 CD80                            int 80h                     ; Make sys_write kernel call
    67 00000054 EBAB                            jmp Read                    ; Loop back and load another buffer full
    68                                          
    69                                  ; All done! Let's end this party...
    70                                  Done:
    71 00000056 B801000000                      mov eax, 1                  ; Code for Exit Syscall
    72 0000005B BB00000000                      mov ebx, 0                  ; Return a code of zero
    73 00000060 CD80                            int 80h                     ; Make sys_exit kernel call
    74                                          
    75                                                
    76                                        
